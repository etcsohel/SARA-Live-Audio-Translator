<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SARA LIVE AUDIO TRANSLATOR</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles if needed, though Tailwind should cover most */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per instructions */
            background-color: #f0f4f8; /* Light gray background */
        }
        /* Style for the text areas to prevent overflow */
        .text-content {
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            word-wrap: break-word; /* Break long words */
            min-height: 120px; /* Minimum height for text fields */
            max-height: 300px; /* Maximum height for text fields */
            overflow-y: auto; /* Scroll if content overflows */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-2xl border border-gray-200">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
            <span class="text-indigo-600">SARA</span> <span class="text-purple-600">LIVE</span> <span class="text-blue-600">AUDIO</span> <span class="text-green-600">TRANSLATOR</span>
        </h1>

        <!-- Language Selection -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <div class="flex flex-col">
                <label for="sourceLanguage" class="text-gray-700 text-sm font-semibold mb-2">Source Language:</label>
                <select id="sourceLanguage" class="p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition-all duration-200 ease-in-out bg-white text-gray-800 shadow-sm">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="flex flex-col">
                <label for="targetLanguage" class="text-gray-700 text-sm font-semibold mb-2">Target Language:</label>
                <select id="targetLanguage" class="p-3 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500 transition-all duration-200 ease-in-out bg-white text-gray-800 shadow-sm">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col sm:flex-row gap-4 mb-6">
            <button id="startSpeakingBtn" class="flex-1 bg-gradient-to-r from-indigo-500 to-blue-600 hover:from-indigo-600 hover:to-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-300 ease-in-out transform hover:-translate-y-1">
                üéôÔ∏è Start Speaking
            </button>
            <button id="playTranslationBtn" class="flex-1 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-300 ease-in-out transform hover:-translate-y-1">
                üîä Play Translation
            </button>
        </div>

        <!-- Status and Loader -->
        <div id="statusMessage" class="text-center text-sm mb-4 text-gray-600"></div>
        <div id="loader" class="hidden text-center mb-4">
            <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-500 inline-block"></div>
            <span class="ml-2 text-indigo-600">Translating...</span>
        </div>

        <!-- Text Fields -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 shadow-inner">
                <label class="block text-gray-700 text-sm font-semibold mb-2">Original Text:</label>
                <div id="originalText" class="text-content text-gray-800 text-base leading-relaxed"></div>
            </div>
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 shadow-inner">
                <label class="block text-gray-700 text-sm font-semibold mb-2">Translated Text:</label>
                <div id="translatedText" class="text-content text-gray-800 text-base leading-relaxed"></div>
                <label class="block text-gray-700 text-sm font-semibold mt-4 mb-2">Pronunciation (English):</label>
                <div id="pronunciationText" class="text-content text-gray-600 text-sm italic"></div>
            </div>
        </div>

        <!-- Footer for developer information -->
        <footer class="mt-8 text-center text-gray-500 text-sm">
            <p>&copy; 2024 SARA LIVE AUDIO TRANSLATOR. Developed by [Your Name/Company Name].</p>
        </footer>
    </div>

    <script>
        // Ensure webkitSpeechRecognition is available
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        // UI Element References
        const sourceLanguageSelect = document.getElementById('sourceLanguage');
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const startSpeakingBtn = document.getElementById('startSpeakingBtn');
        const playTranslationBtn = document.getElementById('playTranslationBtn');
        const originalTextDiv = document.getElementById('originalText');
        const translatedTextDiv = document.getElementById('translatedText');
        const pronunciationTextDiv = document.getElementById('pronunciationText'); // New element
        const statusMessageDiv = document.getElementById('statusMessage');
        const loaderDiv = document.getElementById('loader');

        // Supported Languages (with specific codes for Speech API and LibreTranslate)
        const languages = [
            { name: 'Bengali (India)', speechCode: 'bn-IN', translateCode: 'bn' },
            { name: 'Tamil (India)', speechCode: 'ta-IN', translateCode: 'ta' },
            { name: 'Hindi (India)', speechCode: 'hi-IN', translateCode: 'hi' },
            { name: 'English (US)', speechCode: 'en-US', translateCode: 'en' },
            { name: 'Telugu (India)', speechCode: 'te-IN', translateCode: 'te' },
            { name: 'Kannada (India)', speechCode: 'kn-IN', translateCode: 'kn' },
            { name: 'Malayalam (India)', speechCode: 'ml-IN', translateCode: 'ml' },
            { name: 'Urdu (India)', speechCode: 'ur-IN', translateCode: 'ur' }
        ];

        let recognition; // SpeechRecognition instance
        let isListening = false; // Flag to track microphone status

        // --- Helper Functions ---

        /**
         * Displays a status message to the user.
         * @param {string} message - The message to display.
         * @param {string} type - Optional: 'error', 'success', 'info'. Defaults to 'info'.
         */
        function displayStatus(message, type = 'info') {
            statusMessageDiv.textContent = message;
            statusMessageDiv.className = `text-center text-sm mb-4 ${
                type === 'error' ? 'text-red-600' :
                type === 'success' ? 'text-green-600' :
                'text-gray-600'
            }`;
        }

        /**
         * Toggles the visibility of the loader.
         * @param {boolean} show - True to show, false to hide.
         */
        function toggleLoader(show) {
            loaderDiv.classList.toggle('hidden', !show);
        }

        // --- Initialization ---

        /**
         * Populates the language dropdowns with options.
         */
        function populateLanguageDropdowns() {
            languages.forEach(lang => {
                const sourceOption = document.createElement('option');
                sourceOption.value = lang.speechCode; // Use speechCode for source dropdown value
                sourceOption.textContent = lang.name;
                sourceLanguageSelect.appendChild(sourceOption);

                const targetOption = document.createElement('option');
                targetOption.value = lang.translateCode; // Use translateCode for target dropdown value (for LibreTranslate)
                targetOption.textContent = lang.name;
                targetLanguageSelect.appendChild(targetOption);
            });

            // Set default selections
            sourceLanguageSelect.value = 'en-US';
            targetLanguageSelect.value = 'hi'; // Default target to Hindi
        }

        /**
         * Initializes the SpeechRecognition API.
         */
        function initializeSpeechRecognition() {
            if (!SpeechRecognition) {
                displayStatus('Speech recognition not supported in this browser.', 'error');
                startSpeakingBtn.disabled = true;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = false; // Set to true for continuous listening
            recognition.interimResults = false; // Get final results only

            // Event handler when speech is recognized
            recognition.onresult = async (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0])
                    .map(result => result.transcript)
                    .join('');

                originalTextDiv.textContent = transcript;
                displayStatus('Speech recognized. Translating...', 'info');
                toggleLoader(true);

                try {
                    const translatedText = await translateText(transcript);
                    translatedTextDiv.textContent = translatedText;
                    displayStatus('Translation complete!', 'success');
                    
                    // Automatically play translation after successful translation
                    speakTranslatedText(translatedText);

                    // Get and display pronunciation guide
                    const pronunciation = await getPronunciationGuide(translatedText, targetLanguageSelect.value);
                    pronunciationTextDiv.textContent = pronunciation;

                } catch (error) {
                    console.error('Translation error:', error);
                    displayStatus('Translation failed. Please try again. Error: ' + error.message, 'error');
                } finally {
                    toggleLoader(false);
                }
            };

            // Event handler for errors
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                let errorMessage = `Speech recognition error: ${event.error}`;
                if (event.error === 'not-allowed') {
                    errorMessage = 'Microphone access denied. Please allow microphone permissions in your browser settings.';
                } else if (event.error === 'no-speech') {
                    errorMessage = 'No speech detected. Please speak clearly.';
                }
                displayStatus(errorMessage, 'error');
                isListening = false;
                startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
            };

            // Event handler when recognition ends
            recognition.onend = () => {
                if (isListening) { // If it ended naturally, but we want continuous
                    // We could restart here if continuous was true and we wanted to always listen
                } else {
                    displayStatus('Stopped listening.', 'info');
                }
                isListening = false;
                startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
            };
        }

        // --- Translation Function (using Gemini API) ---

        /**
         * Translates text using the Gemini API.
         * @param {string} text - The text to translate.
         * @returns {Promise<string>} - A promise that resolves with the translated text.
         */
        async function translateText(text) {
            const sourceLangObj = languages.find(lang => lang.speechCode === sourceLanguageSelect.value);
            const targetLangObj = languages.find(lang => lang.translateCode === targetLanguageSelect.value);

            if (!sourceLangObj || !targetLangObj) {
                throw new Error("Invalid source or target language selected.");
            }

            const sourceLangName = sourceLangObj.name.split(' (')[0]; // e.g., "Bengali" from "Bengali (India)"
            const targetLangName = targetLangObj.name.split(' (')[0]; // e.g., "Tamil" from "Tamil (India)"

            const prompt = `Translate the following text from ${sourceLangName} to ${targetLangName}: "${text}". Provide only the translated text, without any additional notes or conversational filler.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyBUkp74PiufhNWc_XLgx_OV-LzK81K7L-U"; // Canvas will automatically provide the API key here
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.json();
                    console.error('Gemini API Translation Error Response:', errorDetails);
                    throw new Error(`Gemini API error: Status ${response.status} - ${errorDetails.error?.message || 'Unknown error'}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    throw new Error('Gemini API returned an empty or malformed response for translation.');
                }
            } catch (error) {
                console.error('Error during Gemini API translation:', error);
                throw new Error(`Translation failed via Gemini API: ${error.message}`);
            }
        }

        // --- Pronunciation Guide Function (using Gemini API) ---
        /**
         * Gets an English pronunciation guide for the given text in the target language.
         * @param {string} text - The text to get pronunciation for.
         * @param {string} targetTranslateCode - The LibreTranslate code of the target language.
         * @returns {Promise<string>} - A promise that resolves with the pronunciation guide.
         */
        async function getPronunciationGuide(text, targetTranslateCode) {
            const targetLangObj = languages.find(lang => lang.translateCode === targetTranslateCode);

            if (!targetLangObj) {
                return "Pronunciation guide not available for this language.";
            }

            const targetLangName = targetLangObj.name.split(' (')[0]; // e.g., "Hindi"

            const prompt = `Provide a simple, easy-to-read English pronunciation guide (using common English letters, not IPA symbols) for the following ${targetLangName} text: "${text}". Only provide the pronunciation guide.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyBUkp74PiufhNWc_XLgx_OV-LzK81K7L-U"; // Canvas will automatically provide the API key here
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.json();
                    console.error('Gemini API Pronunciation Error Response:', errorDetails);
                    throw new Error(`Gemini API error: Status ${response.status} - ${errorDetails.error?.message || 'Unknown error'}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    return "Pronunciation guide not available."; // Fallback message
                }
            } catch (error) {
                console.error('Error during Gemini API pronunciation guide generation:', error);
                return `Failed to get pronunciation: ${error.message}`;
            }
        }


        // --- Text-to-Speech Function ---

        /**
         * Speaks the provided text using SpeechSynthesis API.
         * @param {string} text - The text to speak.
         */
        function speakTranslatedText(text) {
            if (!text) {
                displayStatus('No translated text to play.', 'info');
                return;
            }
            if (!'speechSynthesis' in window) {
                displayStatus('Text-to-speech not supported in this browser.', 'error');
                return;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            const selectedLang = languages.find(lang => lang.translateCode === targetLanguageSelect.value);
            if (selectedLang) {
                 utterance.lang = selectedLang.speechCode; // Use the speechCode for synthesis
            } else {
                 utterance.lang = targetLanguageSelect.value; // Fallback to translateCode if speechCode not found
            }

            // Ensure a voice is available for the selected language
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voices.find(voice => voice.lang === utterance.lang || voice.lang.startsWith(utterance.lang.split('-')[0]));
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            } else {
                console.warn(`No specific voice found for ${utterance.lang}, using default.`);
            }

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                displayStatus(`Failed to play audio: ${event.error}`, 'error');
            };

            speechSynthesis.speak(utterance);
            displayStatus('Playing translation...', 'info');
        }

        // --- Event Listeners ---

        startSpeakingBtn.addEventListener('click', () => {
            if (isListening) {
                recognition.stop();
                isListening = false;
                startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
                displayStatus('Stopped listening.', 'info');
            } else {
                try {
                    // Update the recognition language based on selected source
                    recognition.lang = sourceLanguageSelect.value;
                    originalTextDiv.textContent = '';
                    translatedTextDiv.textContent = '';
                    pronunciationTextDiv.textContent = ''; // Clear pronunciation text
                    recognition.start();
                    isListening = true;
                    startSpeakingBtn.textContent = 'üõë Stop Speaking';
                    displayStatus('Listening... Speak now.', 'info');
                } catch (error) {
                    console.error('Error starting recognition:', error);
                    displayStatus('Failed to start microphone. Please ensure permissions are granted.', 'error');
                }
            }
        });

        playTranslationBtn.addEventListener('click', () => {
            const translatedText = translatedTextDiv.textContent;
            if (translatedText) {
                speakTranslatedText(translatedText);
            } else {
                displayStatus('No translated text available to play.', 'info');
            }
        });

        // Event listener for target language change
        targetLanguageSelect.addEventListener('change', async () => {
            const currentOriginalText = originalTextDiv.textContent.trim();
            if (currentOriginalText) {
                displayStatus('Language changed. Re-translating...', 'info');
                toggleLoader(true);
                translatedTextDiv.textContent = ''; // Clear previous translation
                pronunciationTextDiv.textContent = ''; // Clear previous pronunciation

                try {
                    const translatedText = await translateText(currentOriginalText);
                    translatedTextDiv.textContent = translatedText;
                    displayStatus('Re-translation complete!', 'success');
                    speakTranslatedText(translatedText);

                    // Get and display pronunciation guide for re-translated text
                    const pronunciation = await getPronunciationGuide(translatedText, targetLanguageSelect.value);
                    pronunciationTextDiv.textContent = pronunciation;

                } catch (error) {
                    console.error('Re-translation error:', error);
                    displayStatus('Re-translation failed. Please try again. Error: ' + error.message, 'error');
                } finally {
                    toggleLoader(false);
                }
            } else {
                displayStatus('No original text to re-translate.', 'info');
                translatedTextDiv.textContent = ''; // Clear previous translation if any
                pronunciationTextDiv.textContent = ''; // Clear previous pronunciation if any
            }
        });


        // Initialize on page load
        window.onload = () => {
            populateLanguageDropdowns();
            initializeSpeechRecognition();
            displayStatus('Select languages and click "Start Speaking".');

            // Force load voices for SpeechSynthesis (sometimes they aren't ready immediately)
            if ('speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = () => {
                    console.log('Voices loaded.');
                    // You can optionally check for voice availability here.
                };
                // Call getVoices to prompt the browser to load them if they're not already
                speechSynthesis.getVoices();
            }
        };

    </script>
</body>
</html>
