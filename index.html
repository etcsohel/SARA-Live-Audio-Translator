<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SARA LIVE AUDIO TRANSLATOR</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles if needed, though Tailwind should cover most */
        body {
            font-family: 'Inter', sans-serif; /* Using Inter font as per instructions */
            background-color: #f0f4f8; /* Light gray background */
        }
        /* Style for the text areas to prevent overflow */
        .text-content {
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            word-wrap: break-word; /* Break long words */
            min-height: 120px; /* Minimum height for text fields */
            max-height: 300px; /* Maximum height for text fields */
            overflow-y: auto; /* Scroll if content overflows */
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-2xl shadow-xl w-full max-w-2xl border border-gray-200">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
            <span class="text-indigo-600">SARA</span> <span class="text-purple-600">LIVE</span> <span class="text-blue-600">AUDIO</span> <span class="text-green-600">TRANSLATOR</span>
        </h1>

        <!-- Mode Selection Buttons -->
        <div class="flex justify-center gap-4 mb-6">
            <button id="normalModeBtn" class="flex-1 max-w-[150px] bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out">
                Normal Mode
            </button>
            <button id="speakingModeBtn" class="flex-1 max-w-[150px] bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-300 ease-in-out">
                Speaking Mode
            </button>
        </div>

        <!-- Language Selection -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6 relative">
            <div class="flex flex-col">
                <label for="sourceLanguage" class="text-gray-700 text-sm font-semibold mb-2">Source Language:</label>
                <select id="sourceLanguage" class="p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition-all duration-200 ease-in-out bg-white text-gray-800 shadow-sm">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <div class="flex flex-col">
                <label for="targetLanguage" class="text-gray-700 text-sm font-semibold mb-2">Target Language:</label>
                <select id="targetLanguage" class="p-3 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500 transition-all duration-200 ease-in-out bg-white text-gray-800 shadow-sm">
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>
            <!-- Swap Languages Button -->
            <button id="swapLanguagesBtn" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-gray-200 p-2 rounded-full shadow-md hover:bg-gray-300 transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400">
                üîÑ
            </button>
        </div>

        <!-- Action Buttons -->
        <div class="flex flex-col sm:flex-row gap-4 mb-6">
            <button id="startSpeakingBtn" class="flex-1 bg-gradient-to-r from-indigo-500 to-blue-600 hover:from-indigo-600 hover:to-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-300 ease-in-out transform hover:-translate-y-1">
                üéôÔ∏è Start Speaking
            </button>
            <button id="playTranslationBtn" class="flex-1 bg-gradient-to-r from-purple-500 to-pink-600 hover:from-purple-600 hover:to-pink-700 text-white font-bold py-3 px-6 rounded-lg shadow-md hover:shadow-lg transition-all duration-300 ease-in-out transform hover:-translate-y-1">
                üîä Play Translation
            </button>
        </div>

        <!-- Status and Loader -->
        <div id="statusMessage" class="text-center text-sm mb-4 text-gray-600"></div>
        <div id="loader" class="hidden text-center mb-4">
            <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-500 inline-block"></div>
            <span class="ml-2 text-indigo-600">Translating...</span>
        </div>

        <!-- Text Fields -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 shadow-inner">
                <label class="block text-gray-700 text-sm font-semibold mb-2">Original Text:</label>
                <div id="originalText" class="text-content text-gray-800 text-base leading-relaxed"></div>
            </div>
            <div class="bg-gray-50 p-4 rounded-lg border border-gray-200 shadow-inner">
                <label class="block text-gray-700 text-sm font-semibold mb-2">Translated Text:</label>
                <div id="translatedText" class="text-content text-gray-800 text-base leading-relaxed"></div>
                <label class="block text-gray-700 text-sm font-semibold mt-4 mb-2">Pronunciation (English):</label>
                <div id="pronunciationText" class="text-content text-gray-600 text-sm italic"></div>
            </div>
        </div>

        <!-- Footer for developer information -->
        <footer class="mt-8 text-center text-gray-500 text-sm">
            <p>&copy; 2024 SARA LIVE AUDIO TRANSLATOR. Developed by [Your Name/Company Name].</p>
        </footer>
    </div>

    <script>
        // Ensure webkitSpeechRecognition is available
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        // UI Element References
        const normalModeBtn = document.getElementById('normalModeBtn');
        const speakingModeBtn = document.getElementById('speakingModeBtn');
        const sourceLanguageSelect = document.getElementById('sourceLanguage');
        const targetLanguageSelect = document.getElementById('targetLanguage');
        const swapLanguagesBtn = document.getElementById('swapLanguagesBtn');
        const startSpeakingBtn = document.getElementById('startSpeakingBtn');
        const playTranslationBtn = document.getElementById('playTranslationBtn');
        const originalTextDiv = document.getElementById('originalText');
        const translatedTextDiv = document.getElementById('translatedText');
        const pronunciationTextDiv = document.getElementById('pronunciationText');
        const statusMessageDiv = document.getElementById('statusMessage');
        const loaderDiv = document.getElementById('loader');

        // Global state variables
        let recognition; // SpeechRecognition instance
        let isListening = false; // Flag to track microphone status
        let isSpeakingMode = false; // Flag for Speaking Mode

        // Supported Languages (with specific codes for Speech API and LibreTranslate)
        const languages = [
            { name: 'Bengali (India)', speechCode: 'bn-IN', translateCode: 'bn' },
            { name: 'Tamil (India)', speechCode: 'ta-IN', translateCode: 'ta' },
            { name: 'Hindi (India)', speechCode: 'hi-IN', translateCode: 'hi' },
            { name: 'English (US)', speechCode: 'en-US', translateCode: 'en' },
            { name: 'Telugu (India)', speechCode: 'te-IN', translateCode: 'te' },
            { name: 'Kannada (India)', speechCode: 'kn-IN', translateCode: 'kn' },
            { name: 'Malayalam (India)', speechCode: 'ml-IN', translateCode: 'ml' },
            { name: 'Urdu (India)', speechCode: 'ur-IN', translateCode: 'ur' }
        ];

        // --- Helper Functions ---

        /**
         * Displays a status message to the user.
         * @param {string} message - The message to display.
         * @param {string} type - Optional: 'error', 'success', 'info'. Defaults to 'info'.
         */
        function displayStatus(message, type = 'info') {
            statusMessageDiv.textContent = message;
            statusMessageDiv.className = `text-center text-sm mb-4 ${
                type === 'error' ? 'text-red-600' :
                type === 'success' ? 'text-green-600' :
                'text-gray-600'
            }`;
        }

        /**
         * Toggles the visibility of the loader.
         * @param {boolean} show - True to show, false to hide.
         */
        function toggleLoader(show) {
            loaderDiv.classList.toggle('hidden', !show);
        }

        /**
         * Swaps the selected source and target languages in the dropdowns.
         */
        function swapLanguages() {
            const currentSourceSpeechCode = sourceLanguageSelect.value;
            const currentTargetTranslateCode = targetLanguageSelect.value;

            // Find the language objects based on current values
            const currentSourceLangObj = languages.find(l => l.speechCode === currentSourceSpeechCode);
            const currentTargetLangObj = languages.find(l => l.translateCode === currentTargetTranslateCode);

            if (currentSourceLangObj && currentTargetLangObj) {
                // Set source to the target's speechCode
                sourceLanguageSelect.value = currentTargetLangObj.speechCode;
                // Set target to the source's translateCode
                targetLanguageSelect.value = currentSourceLangObj.translateCode;
            } else {
                console.warn("Could not find language objects for swapping. Using defaults.");
                // Fallback to defaults if for some reason a selected language isn't found
                sourceLanguageSelect.value = 'en-US';
                targetLanguageSelect.value = 'hi';
            }
        }

        /**
         * Sets the application mode (Normal or Speaking).
         * @param {boolean} mode - true for Speaking Mode, false for Normal Mode.
         */
        function setAppMode(mode) {
            isSpeakingMode = mode;
            if (isSpeakingMode) {
                speakingModeBtn.classList.remove('bg-gray-300', 'hover:bg-gray-400', 'text-gray-800');
                speakingModeBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'text-white');
                normalModeBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700', 'text-white');
                normalModeBtn.classList.add('bg-gray-300', 'hover:bg-gray-400', 'text-gray-800');
                swapLanguagesBtn.classList.add('opacity-50', 'cursor-not-allowed');
                displayStatus('Switched to Speaking Mode. Click "Start Speaking" to begin loop.');
            } else {
                normalModeBtn.classList.remove('bg-gray-300', 'hover:bg-gray-400', 'text-gray-800');
                normalModeBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700', 'text-white');
                speakingModeBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700', 'text-white');
                speakingModeBtn.classList.add('bg-gray-300', 'hover:bg-gray-400', 'text-gray-800');
                swapLanguagesBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                displayStatus('Switched to Normal Mode.');
                // If we were listening in speaking mode, stop it gracefully
                if (isListening) {
                    recognition.stop();
                    isListening = false;
                    startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
                }
            }
        }

        // --- Initialization ---

        /**
         * Populates the language dropdowns with options.
         */
        function populateLanguageDropdowns() {
            languages.forEach(lang => {
                const sourceOption = document.createElement('option');
                sourceOption.value = lang.speechCode;
                sourceOption.textContent = lang.name;
                sourceLanguageSelect.appendChild(sourceOption);

                const targetOption = document.createElement('option');
                targetOption.value = lang.translateCode;
                targetOption.textContent = lang.name;
                targetLanguageSelect.appendChild(targetOption);
            });

            // Set default selections
            sourceLanguageSelect.value = 'en-US';
            targetLanguageSelect.value = 'hi';
        }

        /**
         * Initializes the SpeechRecognition API.
         */
        function initializeSpeechRecognition() {
            if (!SpeechRecognition) {
                displayStatus('Speech recognition not supported in this browser.', 'error');
                startSpeakingBtn.disabled = true;
                return;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = false; // We manage continuity manually for the loop
            recognition.interimResults = false;

            // Event handler when speech is recognized
            recognition.onresult = async (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0])
                    .map(result => result.transcript)
                    .join('');

                originalTextDiv.textContent = transcript;
                displayStatus('Speech recognized. Translating...', 'info');
                toggleLoader(true);

                try {
                    const translatedText = await translateText(transcript);
                    translatedTextDiv.textContent = translatedText;
                    displayStatus('Translation complete!', 'success');
                    
                    // Play translated text
                    speakTranslatedText(translatedText);

                    // Get and display pronunciation guide
                    const pronunciation = await getPronunciationGuide(translatedText, targetLanguageSelect.value);
                    pronunciationTextDiv.textContent = pronunciation;

                    // Speaking Mode Auto-Loop
                    if (isSpeakingMode) {
                        displayStatus('Swapping languages and restarting listening...');
                        // Wait for speech synthesis to finish before swapping and restarting,
                        // otherwise, the voice might not be fully loaded for the new language.
                        // However, onutteranceend event is often unreliable for exact timing.
                        // For simplicity, we'll proceed immediately after `speak` call.
                        swapLanguages();
                        recognition.lang = sourceLanguageSelect.value; // Update recognition language
                        originalTextDiv.textContent = ''; // Clear for next input
                        translatedTextDiv.textContent = ''; // Clear for next translation
                        pronunciationTextDiv.textContent = ''; // Clear for next pronunciation
                        recognition.start(); // Restart listening automatically
                        startSpeakingBtn.textContent = 'üõë Stop Speaking'; // Keep button text as stop
                        isListening = true;
                    }

                } catch (error) {
                    console.error('Translation error:', error);
                    displayStatus('Translation failed. Please try again. Error: ' + error.message, 'error');
                } finally {
                    toggleLoader(false);
                }
            };

            // Event handler for errors
            recognition.onerror = (event) => {
                console.error('Speech recognition error:', event.error);
                let errorMessage = `Speech recognition error: ${event.error}`;
                if (event.error === 'not-allowed') {
                    errorMessage = 'Microphone access denied. Please allow microphone permissions in your browser settings.';
                } else if (event.error === 'no-speech') {
                    errorMessage = 'No speech detected. Please speak clearly.';
                }
                displayStatus(errorMessage, 'error');
                isListening = false;
                startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
                // If error occurs in speaking mode, stop the loop
                if (isSpeakingMode) {
                    displayStatus('Speaking Mode stopped due to error.', 'error');
                    setAppMode(false); // Revert to normal mode
                }
            };

            // Event handler when recognition ends
            recognition.onend = () => {
                // If not in speaking mode or if an error already stopped it, reset state
                if (!isSpeakingMode && isListening) { // Only reset if manually stopped in Normal Mode
                    displayStatus('Stopped listening.', 'info');
                    isListening = false;
                    startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
                }
                // In speaking mode, the onresult handler handles the restart loop, so we do nothing here.
            };
        }

        // --- Translation Function (using Gemini API) ---

        /**
         * Translates text using the Gemini API.
         * @param {string} text - The text to translate.
         * @returns {Promise<string>} - A promise that resolves with the translated text.
         */
        async function translateText(text) {
            const sourceLangObj = languages.find(lang => lang.speechCode === sourceLanguageSelect.value);
            const targetLangObj = languages.find(lang => lang.translateCode === targetLanguageSelect.value);

            if (!sourceLangObj || !targetLangObj) {
                throw new Error("Invalid source or target language selected.");
            }

            const sourceLangName = sourceLangObj.name.split(' (')[0];
            const targetLangName = targetLangObj.name.split(' (')[0];

            const prompt = `Translate the following text from ${sourceLangName} to ${targetLangName}: "${text}". Provide only the translated text, without any additional notes or conversational filler.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyBUkp74PiufhNWc_XLgx_OV-LzK81K7L-U";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.json();
                    console.error('Gemini API Translation Error Response:', errorDetails);
                    throw new Error(`Gemini API error: Status ${response.status} - ${errorDetails.error?.message || 'Unknown error'}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    throw new Error('Gemini API returned an empty or malformed response for translation.');
                }
            } catch (error) {
                console.error('Error during Gemini API translation:', error);
                throw new Error(`Translation failed via Gemini API: ${error.message}`);
            }
        }

        // --- Pronunciation Guide Function (using Gemini API) ---
        /**
         * Gets an English pronunciation guide for the given text in the target language.
         * @param {string} text - The text to get pronunciation for.
         * @param {string} targetTranslateCode - The LibreTranslate code of the target language.
         * @returns {Promise<string>} - A promise that resolves with the pronunciation guide.
         */
        async function getPronunciationGuide(text, targetTranslateCode) {
            const targetLangObj = languages.find(lang => lang.translateCode === targetTranslateCode);

            if (!targetLangObj) {
                return "Pronunciation guide not available for this language.";
            }

            const targetLangName = targetLangObj.name.split(' (')[0];

            const prompt = `Provide a simple, easy-to-read English pronunciation guide (using common English letters, not IPA symbols) for the following ${targetLangName} text: "${text}". Only provide the pronunciation guide.`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = "AIzaSyBUkp74PiufhNWc_XLgx_OV-LzK81K7L-U";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorDetails = await response.json();
                    console.error('Gemini API Pronunciation Error Response:', errorDetails);
                    throw new Error(`Gemini API error: Status ${response.status} - ${errorDetails.error?.message || 'Unknown error'}`);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    return "Pronunciation guide not available.";
                }
            } catch (error) {
                console.error('Error during Gemini API pronunciation guide generation:', error);
                return `Failed to get pronunciation: ${error.message}`;
            }
        }


        // --- Text-to-Speech Function ---

        /**
         * Speaks the provided text using SpeechSynthesis API.
         * @param {string} text - The text to speak.
         */
        function speakTranslatedText(text) {
            if (!text) {
                displayStatus('No translated text to play.', 'info');
                return;
            }
            if (!'speechSynthesis' in window) {
                displayStatus('Text-to-speech not supported in this browser.', 'error');
                return;
            }

            const utterance = new SpeechSynthesisUtterance(text);
            const selectedLang = languages.find(lang => lang.translateCode === targetLanguageSelect.value);
            if (selectedLang) {
                 utterance.lang = selectedLang.speechCode;
            } else {
                 utterance.lang = targetLanguageSelect.value;
            }

            // Ensure a voice is available for the selected language
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voices.find(voice => voice.lang === utterance.lang || voice.lang.startsWith(utterance.lang.split('-')[0]));
            if (selectedVoice) {
                utterance.voice = selectedVoice;
            } else {
                console.warn(`No specific voice found for ${utterance.lang}, using default.`);
            }

            utterance.onerror = (event) => {
                console.error('Speech synthesis error:', event.error);
                displayStatus(`Failed to play audio: ${event.error}`, 'error');
            };

            speechSynthesis.speak(utterance);
            displayStatus('Playing translation...', 'info');
        }

        // --- Event Listeners ---

        // Mode selection listeners
        normalModeBtn.addEventListener('click', () => setAppMode(false));
        speakingModeBtn.addEventListener('click', () => setAppMode(true));

        startSpeakingBtn.addEventListener('click', () => {
            if (isListening) {
                recognition.stop();
                isListening = false;
                startSpeakingBtn.textContent = 'üéôÔ∏è Start Speaking';
                displayStatus('Stopped listening.', 'info');
                // If we stop manually in Speaking Mode, revert to Normal Mode
                if (isSpeakingMode) {
                    setAppMode(false);
                }
            } else {
                try {
                    // Update the recognition language based on selected source
                    recognition.lang = sourceLanguageSelect.value;
                    originalTextDiv.textContent = '';
                    translatedTextDiv.textContent = '';
                    pronunciationTextDiv.textContent = ''; // Clear pronunciation text
                    recognition.start();
                    isListening = true;
                    startSpeakingBtn.textContent = 'üõë Stop Speaking';
                    displayStatus('Listening... Speak now.', 'info');
                } catch (error) {
                    console.error('Error starting recognition:', error);
                    displayStatus('Failed to start microphone. Please ensure permissions are granted.', 'error');
                }
            }
        });

        playTranslationBtn.addEventListener('click', () => {
            const translatedText = translatedTextDiv.textContent;
            if (translatedText) {
                speakTranslatedText(translatedText);
            } else {
                displayStatus('No translated text available to play.', 'info');
            }
        });

        swapLanguagesBtn.addEventListener('click', async () => {
            if (!isSpeakingMode) { // Only allow swap in Normal Mode
                swapLanguages();
                // If there's original text, re-translate after swap
                const currentOriginalText = originalTextDiv.textContent.trim();
                if (currentOriginalText) {
                    displayStatus('Languages swapped. Re-translating...', 'info');
                    toggleLoader(true);
                    translatedTextDiv.textContent = '';
                    pronunciationTextDiv.textContent = '';

                    try {
                        const translatedText = await translateText(currentOriginalText);
                        translatedTextDiv.textContent = translatedText;
                        displayStatus('Re-translation complete!', 'success');
                        speakTranslatedText(translatedText);
                        const pronunciation = await getPronunciationGuide(translatedText, targetLanguageSelect.value);
                        pronunciationTextDiv.textContent = pronunciation;
                    } catch (error) {
                        console.error('Re-translation error:', error);
                        displayStatus('Re-translation failed after swap. Error: ' + error.message, 'error');
                    } finally {
                        toggleLoader(false);
                    }
                } else {
                    displayStatus('Languages swapped.', 'info');
                }
            } else {
                displayStatus('Swap Languages button is disabled in Speaking Mode.', 'info');
            }
        });

        // Event listener for target language change (for manual re-translation)
        targetLanguageSelect.addEventListener('change', async () => {
            const currentOriginalText = originalTextDiv.textContent.trim();
            if (currentOriginalText) {
                displayStatus('Language changed. Re-translating...', 'info');
                toggleLoader(true);
                translatedTextDiv.textContent = ''; // Clear previous translation
                pronunciationTextDiv.textContent = ''; // Clear previous pronunciation

                try {
                    const translatedText = await translateText(currentOriginalText);
                    translatedTextDiv.textContent = translatedText;
                    displayStatus('Re-translation complete!', 'success');
                    speakTranslatedText(translatedText);

                    // Get and display pronunciation guide for re-translated text
                    const pronunciation = await getPronunciationGuide(translatedText, targetLanguageSelect.value);
                    pronunciationTextDiv.textContent = pronunciation;

                } catch (error) {
                    console.error('Re-translation error:', error);
                    displayStatus('Re-translation failed. Please try again. Error: ' + error.message, 'error');
                } finally {
                    toggleLoader(false);
                }
            } else {
                displayStatus('No original text to re-translate.', 'info');
                translatedTextDiv.textContent = ''; // Clear previous translation if any
                pronunciationTextDiv.textContent = ''; // Clear previous pronunciation if any
            }
        });


        // Initialize on page load
        window.onload = () => {
            populateLanguageDropdowns();
            initializeSpeechRecognition();
            setAppMode(false); // Set to Normal Mode by default
            displayStatus('Select languages and click "Start Speaking".');

            // Force load voices for SpeechSynthesis (sometimes they aren't ready immediately)
            if ('speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = () => {
                    console.log('Voices loaded.');
                    // You can optionally check for voice availability here.
                };
                // Call getVoices to prompt the browser to load them if they're not already
                speechSynthesis.getVoices();
            }
        };

    </script>
</body>
</html>
